#!/usr/bin/env perl

##
# RF Compare
# RNA Framework [http://www.rnaframework.com]
#    
# Author:  Danny Incarnato (dincarnato[at]rnaframework.com)
# Summary: Compares inferred secondary structures to a set of reference structures
#
# This program is free software, and can be redistribute  and/or modified
# under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# any later version.
#
# Please see <http://www.gnu.org/licenses/> for more informations.
##

use strict;
use File::Basename;
use File::Path qw(mkpath);
use FindBin qw($Bin);
use Getopt::Long qw(:config no_ignore_case);

use lib $Bin . "/lib";

use Core::Mathematics qw(:all);
use Core::Utils;
use Data::IO;
use Data::IO::Sequence;
use Data::Sequence::Utils;
use Graphics::Container;
use Graphics::Object::RNAarcs;
use RNA::Utils;
use Term::Table;

$|++;

my ($input, $reference, $refio, $help,
    $table, $relaxed, $kn, $kp,
    $kl, $img, $output, $overwrite,
    $ignoreseq, $error, %results);
%results = ( compared      => 0,
             ioerr         => 0,
             diffseq       => 0,
             missingstruct => 0 );

do {
    
    local $SIG{__WARN__} = sub { };

    GetOptions( "h|help"               => \$help,      
                "r|reference=s"        => \$reference,
                "x|relaxed"            => \$relaxed,
                "kn|keep-noncanonical" => \$kn,
                "kp|keep-pseudoknots"  => \$kp,
                "kl|keep-lonelypairs"  => \$kl,
                "g|img"                => \$img,
                "o|output-dir=s"       => \$output,
                "ow|overwrite"         => \$overwrite,
                "i|ignore-sequence"    => \$ignoreseq ) or help(1);

    $input = $ARGV[0];
                
};

help() if ($help);

$output ||= "rf_compare/";
$output =~ s/\/?$/\//;
$input =~ s/\/?$/\// if (-d $input);

##
# Input validation
##

die "\n  [!] Error: No output directory specified\n\n" if (!defined $output &&
                                                           $img);
die "\n  [!] Error: Provided structure directory\/file doesn't exist\n\n" if (!-e $input);
die "\n  [!] Error: No reference structures file provided\n\n" if (!defined $reference);
die "\n  [!] Error: Reference structures file doesn't exist\n\n" if (!-e $reference);

##
# Read structures
##

if ($img) {
    
    print "\n[+] Making output directory...";

    if (-e $output) {
    
        if ($overwrite) {
            
            my $error = rmtree($output);
        
            die "\n\n  [!] Error: " . $error . "\n\n" if ($error); 
            
        }
        else { die "\n\n  [!] Error: Output directory already exists." .
                   "\n      Please use -ow (or --overwrite) to overwrite output directory\n\n"; }
        
    }
    
    mkpath($output, { mode  => 0755,
                      error => \$error });
    
}

print "\n[+] Comparing structures to reference...";

$refio = Data::IO::Sequence->new( file         => $reference,
                                  noncanonical => $kn,
                                  pseudoknots  => $kp,
                                  lonelypairs  => $kl );

$table = Term::Table->new(indent => 2);
$table->head("Transcript", "PPV", "Sensitivity");

while(my $ref = $refio->read()) {

    die "\n\n  [!] Error: File does not look like a valid Vienna or CT file\n\n" if (!$ref->can("structure"));
    
    my ($file, $refid, $refseq, $refstruct,
        $queryio, $queryseq, $querystruct, $format);
    ($refid, $refseq, $refstruct) = ($ref->id(), $ref->sequence(), $ref->structure());
    
    if (-d $input) {
        
        if (-e $input . $refid . ".ct") { $format = "ct"; }
        elsif (-e $input . $refid . ".db") { $format = "db"; }
        else {
        
            $results{missingstruct}++;
            
            next;
            
        }
        
        $file = $input . $refid . "." . $format;
        
    }
    else {
        
        my ($fileid);
        ($fileid, undef, $format) = fileparse($input, qr/\.[^.]*/);
        $format =~ s/^\.//;
        $file = $input;
        
        #next if ($fileid ne $refid);
        
    }
    
    $queryio = Data::IO::Sequence->new( file         => $file,
                                        pseudoknots  => $kp,
                                        lonelypairs  => $kl );
    
    if (my $query = $queryio->read()) {
        
        $queryseq = $query->sequence();
        $querystruct = $query->structure();
        
    }
    else {
        
        $results{ioerr}++;
        
        next;
    
    }
    
    $refseq = dna2rna($refseq);
    $queryseq = dna2rna($queryseq);
    
    if (!defined $queryseq ||
        !defined $querystruct) {
        
        $results{ioerr}++;
        
        next;
        
    }
    
    if ($queryseq ne $refseq &&
	    !$ignoreseq) {
        
        $results{diffseq}++;
        
        next;
        
    }
    
    $table->row($refid, sprintf("%.2f", ppv($refstruct, $querystruct, $relaxed)), sprintf("%.2f", sensitivity($refstruct, $querystruct, $relaxed)));
    
    if ($img) {
        
        my ($io, $svg, $refarc, $queryarc,
            $outfile, $common, $missing);
        $outfile = $output . $refid . ".svg";
        $io = Data::IO->new( file    => $outfile,
                             mode    => "w",
                             binmode => ":encoding(utf-8)" );
        $svg = Graphics::Container->new( height  => abs(maprange(0, 1000, -500, -250, min($ref->length(), 1000))), # Min: 500 / Max: 1000px
                                         width   => 1000,
                                         spacing => 0 );
        ($common, $missing) = commonpairs($refstruct, $querystruct);
        $refarc = Graphics::Object::RNAarcs->new( height    => 0.5,
                                                  length    => $ref->length(),
                                                  flip      => "up",
                                                  stroke    => [ ("black") x @{$common}, ("rgb(102,51,153)") x @{$missing} ],
                                                  basepairs => [ @{$common}, @{$missing} ] );
        ($common, $missing) = commonpairs($querystruct, $refstruct);
        $queryarc = Graphics::Object::RNAarcs->new( height    => 0.5,
                                                    length    => $ref->length(),
                                                    flip      => "down",
                                                    stroke    => [ ("rgb(12,128,57)") x @{$common}, ("rgb(187,27,27)") x @{$missing} ],
                                                    basepairs => [ @{$common}, @{$missing} ] );
        $svg->addobjects($refarc, $queryarc);
        $io->write($svg->xml());
        
    }
    
    $results{compared}++;
    
}

if ($results{compared}) {
    
    print "\n\n";
    $table->print();
    print "\n";
    
}

$results{missingstruct} = 1 unless (sum(values %results));

print "\n[+] Comparison statistics:\n" .
      "\n  [*] Compared transcripts: " . $results{compared} .
      "\n  [*] Excluded transcripts: " . ($results{ioerr} + $results{diffseq} + $results{missingstruct}) . " total" .
      "\n                            " . $results{ioerr} . " structure file parsing failed" .
      "\n                            " . $results{diffseq} . " mismatch between reference and query transcript sequences" .
      "\n                            " . $results{missingstruct} . " missing structure file";

print "\n\n[+] All done.\n\n";

sub commonpairs {
    
    my ($reference, $structure) = @_;
    
    my (@common, @missing, %reference);
    
    for (listpairs($reference)) { $reference{$_->[0] . "-" . $_->[1]} = 0; }
	for (listpairs($structure)) { $reference{$_->[0] . "-" . $_->[1]} = 1 if (exists $reference{$_->[0] . "-" . $_->[1]}); }

    @common = map { [ split("-", $_) ] } (grep { $reference{$_} } keys %reference);
    @missing = map { [ split("-", $_) ] } (grep { !$reference{$_} } keys %reference);
    
    return(\@common, \@missing);
    
}

sub help {
    
    print "\n  [!] Error: Invalid option. Please check the help\n" if ($_[0]);
    
    die <<HELP;
 
 RF Compare (v$Core::Utils::VERSION)
 RNA Framework [http://www.rnaframework.com]
    
 Author:  Danny Incarnato (dincarnato[at]rnaframework.com)
 Summary: Compares inferred secondary structures to a set of reference structures
 
 Usage:   rf-compare [Options] structures_folder/                # Multiple transcripts
          rf-compare [Options] file.(ct|db)                      # Single transcript
 
 Options                                Description
 -r  or --reference     <string>        A file containing reference structures in Vienna format (dot-bracket)
 -g  or --img                           Enables generation of graphical comparison images
 -o  or --output-dir    <string>        Images output directory (Default: rf_compare/, requires -g)
 -ow or --overwrite                     Overwrites output directory (if the specified path already exists)
 -x  or --relaxed                       Uses relaxed criteria (described in Deigan et al., 2009) to calculate PPV and sensitivity
 -kn or --keep-noncanonical             Keeps non-canonical basepairs in reference structure
 -kp or --keep-pseudoknots              Keeps pseudoknotted basepairs in reference structure
 -kl or --keep-lonelypairs              Keeps lonely basepairs (helices of length 1 bp) in reference structure
 -i  or --ignore-sequence               Ignores sequence differences (e.g. SNVs) between the compared structures
 
HELP
    
}

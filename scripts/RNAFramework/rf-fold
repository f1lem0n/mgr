#!/usr/bin/env perl

##
# RF Fold
# RNA Framework [http://www.rnaframework.com]
#
# Author:  Danny Incarnato (dincarnato[at]rnaframework.com)
# Summary: Produces secondary structures for analyzed transcripts using structural
#          probing data to guide folding
#
# This program is free software, and can be redistribute  and/or modified
# under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# any later version.
#
# Please see <http://www.gnu.org/licenses/> for more informations.
##

use strict;
use Config;
use Cwd;
use File::Basename;
use File::Path qw(mkpath);
use File::Spec;
use FindBin qw($Bin);
use Getopt::Long qw(:config no_ignore_case);
use POSIX qw(floor);
use threads;
use threads::shared;

use lib $Bin . "/lib";

use Core::Mathematics qw(:all);
use Core::Statistics;
use Core::Utils;
use Data::IO;
use Data::IO::Sequence;
use Data::Sequence;
use Data::Sequence::Structure;
use Data::Sequence::Utils;
use Graphics::Container;
use Graphics::Object::Barplot;
use Graphics::Object::Path;
use Graphics::Object::RNAarcs;
use Graphics::Object::Ruler;
use RNA::Utils;
use RF::Data::IO::XML;
use Term::Constants qw(:screen);

use constant MINWINLENGTH => 50; # Minimum window length for windowed folding

die "\n  [!] Error: This program requires ithreads." .
    "\n             Please recompile Perl with ithreads and try again\n\n" unless(exists $Config{useithreads});

$|++;

my ($output, $ct, $input, $method,
    $threads, $img, $t, $noshapevrfoldparams,
    $cutoff, $nlp, $ngu, $rnastructure,
    $viennarna, $data, $slope, $intercept,
    $maxdist, $constmethod, $constconversion, $beta,
    $modslope, $modintercept, $installed, $nfiles,
    $overwrite, $error, $help, $tmpdir,
    $ignore, $madetmp, $hc, $vrfoldparams, $rsfoldparams,
    $windowed, $cwd, $partition, $probplot,
    $partwin, $partstep, $wintrim, $foldwin,
    $foldstep, $dp, $sh, $pk,
    $pkwin, $pkstep, $p1, $p2,
    $pkcutoff, $rnasubopt, $pkmax, $pksubopt,
    $shapeknots, $pkmethod, $skparams, $keeptmp,
    $pkpercentmfe, $nozuker, $zukersubopt, $pkslope,
    $pkintercept, $constraintDir, $plotMedianShape, $plotMedianShannon,
    @pool, %lambda, %constraints);

my %results : shared;
my @xml : shared;
%results = ( folded   => 0,
             parseerr => 0,
             consterr => 0,
             folderr  => 0,
             fastaerr => 0,
             pkerr    => 0 );
%lambda = ( "2"  => 0,
            "3"  => 24,
            "4"  => 24,
            "5"  => 34,
            "6"  => 24,
            "7"  => 35,
            "8"  => 58,
            "9"  => 82,
            "10" => 65,
            "11" => 527,
            "12" => 2447,
            "13" => 4199,
            "14" => 6564,
            "15" => 12540 );

do {

    local $SIG{__WARN__} = sub { };

    GetOptions( "h|help"                     => \$help,
                "o|output-dir=s"             => \$output,
                "ow|overwrite"               => \$overwrite,
                "ct|connectivity-table"      => \$ct,
                "m|folding-method=i"         => \$method,
                "p|processors=i"             => \$threads,
                "g|img"                      => \$img,
                "c|constraints=s"            => \$constraintDir,
                "t|temperature=s"            => \$t,
                "sl|slope=s"                 => \$slope,
                "in|intercept=s"             => \$intercept,
                "md|maximum-distance=i"      => \$maxdist,
                "vrf|vienna-rnafold=s"       => \$viennarna,
                "f|cutoff=s"                 => \$cutoff,
                "nlp|no-lonely-pairs"        => \$nlp,
                "ngu|no-closing-gu"          => \$ngu,
                "cm|constraint-method=i"     => \$constmethod,
                "cc|constraint-conversion=i" => \$constconversion,
                "bf|beta-factor=s"           => \$beta,
                "ms|model-slope=s"           => \$modslope,
                "mi|model-intercept=s"       => \$modintercept,
                "rs|rnastructure=s"          => \$rnastructure,
                "d|data-path=s"              => \$data,
                "i|ignore-reactivity"        => \$ignore,
                "hc|hard-constraint"         => \$hc,
                "w|windowed"                 => \$windowed,
                "fw|fold-window=i"           => \$foldwin,
                "fo|fold-offset=i"           => \$foldstep,
                "wt|window-trim=i"           => \$wintrim,
                "pw|partition-window=i"      => \$partwin,
                "po|partition-offset=i"      => \$partstep,
                "dp|dotplot"                 => \$dp,
                "KT|keep-tmp"                => \$keeptmp,
                "kt|pseudoknot-tollerance=s" => \$pkpercentmfe,
                "sh|shannon-entropy"         => \$sh,
                "pk|pseudoknots"             => \$pk,
                "pt|partition=s"             => \$partition,
                "pp|probabilityplot=s"       => \$probplot,
                "vrs|vienna-rnasubopt=s"     => \$rnasubopt,
                "kw|pseudoknot-window=i"     => \$pkwin,
                "ko|pseudoknot-offset=i"     => \$pkstep,
                "ksl|pseudoknot-slope=s"     => \$pkslope,
                "kin|pseudoknot-intercept=s" => \$pkintercept,
                "kp1|pseudoknot-penality1=s" => \$p1,
                "kp2|pseudoknot-penality2=s" => \$p2,
                "kc|pseudoknot-cutoff=s"     => \$pkcutoff,
                "ks|pseudoknot-suboptimal=i" => \$pksubopt,
                "kh|pseudoknot-helices=i"    => \$pkmax,
                "km|pseudoknot-method=i"     => \$pkmethod,
                "sk|shapeknots=s"            => \$shapeknots,
                "nz|no-zuker"                => \$nozuker,
                "zs|zuker-suboptimal=i"      => \$zukersubopt,
                "pmr|plot-median-react"      => \$plotMedianShape,
                "pms|plot-median-shannon"    => \$plotMedianShannon ) or help(1);

    $input = $ARGV[0];

};

help() if ($help);

# Default
$madetmp = 0;
$cwd = cwd();
$output ||= "rf_fold/";
$tmpdir ||= $output . "/tmp/";
$method ||= 1;
$threads ||= 1;
$t //= 37.0;
$cutoff //= 0.7;
$slope //= 1.8;
$intercept //= -0.6;
$pkslope //= $slope;
$pkintercept //= $intercept;
$constmethod ||= 1;
$constconversion ||= 1;
$beta //= 0.5;
$maxdist //= 0;
$partwin ||= 600;
$partstep ||= 200;
$wintrim //= 100;
$foldwin ||= 600;
$foldstep ||= 200;
$pkwin ||= 600;
$pkstep ||= 200;
$p1 //= 0.35;
$p2 //= 0.65;
$pkcutoff //= 0.5;
$pkmax ||= 100;
$pksubopt ||= 1000;
$zukersubopt ||= 1000;
$pkmethod ||= 1;
$pkpercentmfe ||= 0.5;
$viennarna = File::Spec->rel2abs($viennarna || which("RNAfold"));
$rnasubopt = File::Spec->rel2abs($rnasubopt || which("RNAsubopt"));
$rnastructure = File::Spec->rel2abs($rnastructure || which("Fold-smp") || which("Fold"));
$shapeknots = File::Spec->rel2abs($shapeknots || which("ShapeKnots-smp") || which("ShapeKnots"));
$partition = File::Spec->rel2abs($partition || which("partition-smp") || which("partition"));
$probplot = File::Spec->rel2abs($probplot || which("ProbabilityPlot"));
$data ||= $ENV{DATAPATH};
$installed = eval { require RNA; 1; };

$output =~ s/\/?$/\//;
$tmpdir =~ s/\/?$/\//;
$constraintDir =~ s/\/?$/\// if (defined $constraintDir);

##
# Input validation
##

die "\n  [!] Error: No output directory specified\n\n" unless(defined $output);
die "\n  [!] Error: No XML directory\/file specified\n\n" if (!defined $input);
die "\n  [!] Error: Provided XML directory\/file doesn't exist\n\n" if (!-e $input);
die "\n  [!] Error: Provided constraint directory doesn't exist\n\n" if (defined $constraintDir && !-d $constraintDir);
die "\n  [!] Error: Number of processors must be an integer greater than 0\n\n" if ($threads < 1);
die "\n  [!] Error: Invalid folding method\n\n" unless($method =~ m/^[12]$/);
die "\n  [!] Error: Temperature must be a positive value\n\n" unless(ispositive($t));
die "\n  [!] Error: Temperature must be comprised between 0 and 100 degree Celsius\n\n" if ($t > 100);
die "\n  [!] Error: Invalid slope value\n\n" unless(isreal($slope));
die "\n  [!] Error: Invalid intercept value\n\n" unless(isreal($intercept));
die "\n  [!] Error: Maximum distance value must be a positive integer\n\n" if (!ispositive($maxdist));
die "\n  [!] Error: No closing GU parameter requires folding method 1 (ViennaRNA)\n\n" if ($ngu &&
                                                                                           $method != 1);
die "\n  [!] Error: Invalid constraint conversion method\n\n" if ($constconversion !~ m/^[1-5]$/);
die "\n  [!] Error: Reactivity cutoff must be a value >0 and <= 1" if (!inrange($cutoff, [0, 1]));

if ($windowed) {

    die "\n  [!] Error: Folding window's size must be an integer >= 50\n\n" unless($foldwin >= MINWINLENGTH);
    die "\n  [!] Error: Folding window's sliding offset cannot be greater than window's size\n\n" if ($foldstep > $foldwin);
    die "\n  [!] Error: Parition function window's size must be an integer >= 50\n\n" unless($partwin >= MINWINLENGTH);
    die "\n  [!] Error: Partition function window's sliding offset cannot be greater than window's size\n\n" if ($partstep > $partwin);
    die "\n  [!] Error: Partition function window's trimming value cannot exceed half of" .
        "\n             the difference between window's size and sliding offset size\n\n" if ($wintrim > int(($partwin - $partstep) / 2));

}

if ($pk) {

    die "\n  [!] Error: Invalid pseudoknots prediction method\n\n" unless($pkmethod =~ m/^[12]$/);
    die "\n  [!] Error: Pseudoknot window's size must be an integer >= 50\n\n" unless($pkwin >= MINWINLENGTH);
    die "\n  [!] Error: Pseudoknot window's sliding offset cannot be greater than window's size\n\n" if ($pkstep > $pkwin);
    die "\n  [!] Error: Pseudoknot penality 1 must be numeric\n\n" unless(isnumeric($p1));
    die "\n  [!] Error: Pseudoknot penality 2 must be numeric\n\n" unless(isnumeric($p2));
    die "\n  [!] Error: Pseudoknot reactivity cutoff must be a value >0 and <= 1" if (!inrange($pkcutoff, [0, 1]));
    die "\n  [!] Error: Pseudoknot suboptimal structures energy tollerance must be numeric" if (!isnumeric($pkpercentmfe));
    die "\n  [!] Error: Pseudoknot suboptimal structures energy tollerance must be a value >0 and <= 1" if (!inrange($pkpercentmfe, [0, 1]));

}

if ($constmethod == 2) { # Zarringhalam et al., 2012

    if ($constconversion == 4) {

        $modslope = 0.68 if (!defined $modslope);
        $modintercept = 0.2 if (!defined $modintercept);

    }
    elsif ($constconversion == 5) {

        $modslope = 1.6 if (!defined $modslope);
        $modintercept = -2.29 if (!defined $modintercept);

    }

    die "\n  [!] Error: Invalid constraint conversion method\n\n" unless($method =~ m/^[1-5]$/);
    die "\n  [!] Error: Invalid beta factor value\n\n" if (!isnumeric($beta));
    die "\n  [!] Error: Constraining cutoff must be a positive value\n\n" if ($constconversion == 3 &&
                                                                              !ispositive($cutoff));       # ViennaRNA 'C'
    die "\n  [!] Error: Invalid linear model's slope value\n\n" if ($constconversion =~ m/^[45]$/ &&
                                                                    !isnumeric($modslope));                # ViennaRNA 'L' & 'O'
    die "\n  [!] Error: Invalid linear model's intercept value\n\n" if ($constconversion =~ m/^[45]$/ &&
                                                                        !isnumeric($modintercept));        # ViennaRNA 'L' & 'O'

}

die "\n  [!] Error: ViennaRNA package's Perl module RNA.pm is required." .
    "\n             Please ensure that ViennaRNA package v2.2.0 (or greater) is installed and try again\n\n" unless($installed);

print "\n[+] Checking method's requirements...";

if ($method == 1) { # ViennaRNA

    my $ret = `$viennarna --version`;

    if ($ret =~ m/RNAfold (\d+)\.(\d+)/) {

        my ($v1, $v2) = ($1, $2);

        die "\n\n  [!] Error: RF Fold requires ViennaRNA package v2.2.0 or greater (Detected: v" . $v1 . "." . $v2 . ")\n\n" if ($v1 < 2 ||
                                                                                                                                  $v2 < 2);

    }
    else { warn "\n\n  [!] Warning: Unable to detect ViennaRNA package version\n"; }

}
else { # RNAstructure

    if (!defined $data) { die "\n\n  [!] Error: Environment variable DATAPATH is not set\n\n"; }
    elsif (!-d $data) { die "\n\n  [!] Error: Provided DATAPATH directory doesn't exist\n\n"; }

    if (!defined $rnastructure) { die "\n\n  [!] Error: RNAstructure Fold is not in PATH\n\n"; }
    elsif (!-e $rnastructure) { die "\n\n  [!] Error: RNAstructure Fold doesn't exist\n\n"; }
    elsif (!-x $rnastructure) { die "\n\n  [!] Error: RNAstructure Fold is not executable\n\n"; }

    if (!defined $partition) { die "\n\n  [!] Error: RNAstructure partition is not in PATH\n\n"; }
    elsif (!-e $partition) { die "\n\n  [!] Error: RNAstructure partition doesn't exist\n\n"; }
    elsif (!-x $partition) { die "\n\n  [!] Error: RNAstructure partition is not executable\n\n"; }

    if (!defined $probplot) { die "\n\n  [!] Error: RNAstructure ProbabilityPlot is not in PATH\n\n"; }
    elsif (!-e $probplot) { die "\n\n  [!] Error: RNAstructure ProbabilityPlot doesn't exist\n\n"; }
    elsif (!-x $probplot) { die "\n\n  [!] Error: RNAstructure ProbabilityPlot is not executable\n\n"; }

    $ENV{DATAPATH} = $data;

}

if ($pk) {

    if ($pkmethod == 1) {

        if (!defined $rnasubopt) { die "\n\n  [!] Error: RNAsubopt is not in PATH\n\n"; }
        elsif (!-e $rnasubopt) { die "\n\n  [!] Error: RNAsubopt doesn't exist\n\n"; }
        elsif (!-x $rnasubopt) { die "\n\n  [!] Error: RNAsubopt is not executable\n\n"; }

    }
    else {

        if (!defined $shapeknots) { die "\n\n  [!] Error: ShapeKnots is not in PATH\n\n"; }
        elsif (!-e $shapeknots) { die "\n\n  [!] Error: ShapeKnots doesn't exist\n\n"; }
        elsif (!-x $shapeknots) { die "\n\n  [!] Error: ShapeKnots is not executable\n\n"; }

    }

}

# Setting folding parameters
if ($method == 1 ||
    $pkmethod == 1) { # ViennaRNA

    $vrfoldparams = " -T " . $t;
    $vrfoldparams .= " --noLP" if ($nlp);
    $vrfoldparams .= " --noClosingGU" if ($ngu);
    $vrfoldparams .= " --maxBPspan=" . $maxdist if ($maxdist);
    $noshapevrfoldparams = $vrfoldparams;

    if (!$ignore) {

        if ($constmethod == 1) {  # Deigan et al., 2009 (ViennaRNA 'D')

            $vrfoldparams .= " --shapeMethod=Dm" . $slope . "b" . $intercept;

        }
        else {  # Zarringhalam et al., 2012 (ViennaRNA 'Z')

            $vrfoldparams .= " --shapeMethod=Zb" . $beta . " --shapeConversion=";

            if ($constconversion == 1) { $vrfoldparams .= "S"; }                                             # ViennaRNA 'S'
            elsif ($constconversion == 2) { $vrfoldparams .= "M"}                                            # ViennaRNA 'M'
            elsif ($constconversion == 3) { $vrfoldparams .= "C" . $cutoff; }                                # ViennaRNA 'C'
            elsif ($constconversion == 4) { $vrfoldparams .= "Ls" . $modslope . "i" . $modintercept; }       # ViennaRNA 'L'
            else { $vrfoldparams .= "Os" . $modslope . "i" . $modintercept; }                                # ViennaRNA 'O'

        }

    }

}

if ($method == 2 ||
    $pkmethod == 2) { # RNAstructure

    $skparams = $rsfoldparams;

    if (!$ignore) {

        $rsfoldparams .= " -si " . $intercept . " -sm " . $slope;
        $skparams .= " -si " . $pkintercept . " -sm " . $pkslope;

    }

    $rsfoldparams .= " -md " . $maxdist if ($maxdist);
    $rsfoldparams .= " -t " . ($t + 273.15);         # RNAstructure expects a temperature in Kelvin degrees

}

# Output directory tree
print "\n[+] Making output directory tree...";

if (-e $output) {

    if ($overwrite) {

        my $error = rmtree($output);

        die "\n\n  [!] Error: " . $error . "\n\n" if ($error);

    }
    else { die "\n\n  [!] Error: Output directory already exists." .
               "\n      Please use -ow (or --overwrite) to overwrite output directory\n\n"; }

}

mkpath($output . "structures", { mode  => 0755,
                                 error => \$error });
mkpath($output . "images", { mode  => 0755,
                             error => \$error }) if ($img);
mkpath($output . "dotplot", { mode  => 0755,
                              error => \$error }) if ($dp);

mkpath($output . "shannon", { mode  => 0755,
                              error => \$error }) if ($sh);

die "\n\n  [!] Error: Unable to create output directory (" . $error->[0]->{each(%{$error->[0]})} . ")\n\n" if (@{$error});

if (!-e $tmpdir) {

    mkpath($tmpdir, { mode  => 0755,
                      error => \$error });

    die "\n\n  [!] Error: Unable to create temporary directory (" . $error->[0]->{each(%{$error->[0]})} . ")\n\n" if (@{$error});

    $madetmp = 1;

}
else { die "\n\n  [!] Error: The path to the specified temporary folder is not a directory\n\n" if (!-d $tmpdir); }

# Sets all paths to absolute, before changing working directory to temp dir
$output = File::Spec->rel2abs($output) . "/";
$tmpdir = File::Spec->rel2abs($tmpdir) . "/";

print "\n[+] Importing XML file(s) [0 imported]";

if (-d $input) {

    opendir(my $dh, $input) or die "\n\n  [!] Error: Unable to read XML files from directory\n\n";
    while(my $file = readdir($dh)) {

        next if ($file !~ m/\.xml$/);

        push(@xml, File::Spec->rel2abs($input . "/" . $file));
        print CLRRET . "[+] Importing XML file(s) [" . scalar(@xml) . " imported]";

    }
    closedir($dh);

    die "\n\n  [!] Error: Specified folder doesn't contain any XML file\n\n" unless(@xml);

}
else { # Single xml file

    die "\n\n  [!] Error: Provided file lacks XML extension\n\n" if ($input !~ m/\.xml$/);

    print CLRRET . "[+] Importing XML file(s) [1 imported]";
    push(@xml, File::Spec->rel2abs($input));

}

warn "\n\n  [!] Ignoring XML reactivity data files. Predicting MFE unconstrained structures...\n" if ($ignore);

if ($constraintDir) {

    print "\n[+] Importing constraint file(s) [0 imported]";

    opendir(my $dh, $constraintDir) or die "\n\n  [!] Error: Unable to read constraint files from directory\n\n";
    while(my $file = readdir($dh)) {

        next if ($file =~ m/^\./);

        my $eval = do { local $@;
                        eval {

                            my ($structIO, $entry, $structure);
                            $structIO = Data::IO::Sequence->new( file         => $constraintDir . $file,
                                                                 lonelypairs  => 1 );
                            $entry = $structIO->read();
                            $structure = $entry->structure();
                            $constraints{$entry->id()} = $structure;

                     };
                     $@; };

        print CLRRET . "[+] Importing constraint file(s) [" . scalar(keys %constraints) . " imported]";

    }
    closedir($dh);

}

chdir($tmpdir);  # Change the working directory before starting threads

print "\n[+] Folding RNA structures [Last: none]";

$nfiles = @xml;
@pool = map{ threads->create(\&fold) } 1 .. $threads;
$_->join() for (@pool);

chdir($cwd);  # Reset to original working directory

my $ioerr = $nfiles;
$ioerr -= $_ for (values %results);

print "\n[+] Folding statistics:\n" .
      "\n  [*] Folded transcripts:    " . $results{folded} .
      "\n  [*] Discarded transcripts: " . ($nfiles - $results{folded}) . " total" .
      "\n                             " . $results{parseerr} . " XML parsing failed" .
      "\n                             " . $results{consterr} . " constraint file generation failed" .
      "\n                             " . $results{fastaerr} . " FASTA file generation failed" .
      "\n                             " . $results{folderr} . " folding failed" .
      "\n                             " . $ioerr . " I/O error";

print "\n                             " . $results{pkerr} . " pseudoknotted folding failed" if ($pk);

rmtree($tmpdir) if ($madetmp &&
                    !$keeptmp);

print "\n\n[+] All done.\n\n";

sub fold { # Threads

    TRANSCRIPT:
    while(1) {

        my ($xml);

        { lock(@xml);
          $xml = shift(@xml) if (@xml); }

        last unless($xml);

        my ($sequence, $id, $structure, $cmd,
            $xmlref, $ret, $entry, $length,
            $nwins, $file, $io, $energy,
            $constraint, @foldwins, @windows, @constraint,
            @pkpairs, @keptpairs, @dotplot, @shannon,
            @reactivity, %pairprobs, %npairs, %seen);

        eval { $xmlref = RF::Data::IO::XML->new(file => $xml); };

        if ($@) {

            lock(%results);
            $results{parseerr}++;

            undef($@);

            next;

        }

        $id = $xmlref->id();
        $sequence = $xmlref->sequence();
        $length = $xmlref->length();
        @reactivity = $xmlref->reactivity();
        $constraint = exists $constraints{$id} ? $constraints{$id} : "." x $length;

        ######### Partition function block ##########

        # We enter here only if we need to do windowed analysis, or if
        # the user requests the bp dotplot or the shannon entropy
        if ($windowed ||
            $sh ||
            $dp) {

            $nwins = $windowed ? max(1, floor(($length - $partwin) / $partstep) + 1) : 1;

            # Define windows to be analyzed
            # Windows are defined as: [start, end, 5'-trim, 3'-trim]
            if ($nwins > 1) {

                for (50, 100) {

                    my $end = $partwin - $_ - 1;

                    last if ($end < MINWINLENGTH - 1);

                    push(@foldwins, [0, $end, 0, $wintrim]);

                }

                for (0 .. $nwins - 1) {

                    my ($start, $end);
                    $start = $partstep * $_;
                    $end = $_ == $nwins - 1 ? $length - 1 : $start + $partwin - 1;
                    push(@foldwins, [$start, $end, $wintrim, $wintrim]);

                }

                for (50, 100) {

                    my $start = $length - $partwin + $_;

                    last if ($start > $length - MINWINLENGTH);

                    push(@foldwins, [$start, $length - 1, $wintrim, 0]);

                }

            }
            else { push(@foldwins, [0, $length - 1, 0, 0]); }

            # This fixes the cases in which the first or last windows are < MINWINLENGTH
            $foldwins[0]->[2] = 0;
            $foldwins[-1]->[3] = 0;

            # Calculate window partition function
            foreach my $win (@foldwins) {

                my ($start, $end, $trim5, $trim3,
                    $winconst, $subseq, $tmpfile, @winreact);
                ($start, $end, $trim5, $trim3) = @{$win};

                $subseq = substr($sequence, $start, $end - $start + 1);
                $winconst = fixdotbracket(substr($constraint, $start, $end - $start + 1));
                @winreact = @reactivity[$start .. $end];
                $tmpfile = $id . "_" . $start . "-" . $end . "_" . threads->tid();

                my ($win, $shannon) = partition( file       => $tmpfile,
                                                 sequence   => $subseq,
                                                 reactivity => \@winreact,
                                                 pos        => $start,
                                                 trim5      => $trim5,
                                                 trim3      => $trim3,
                                                 constraint => $winconst );

                if (!$win) {

                    lock(%results);
                    $results{folderr}++;

                    unlink(glob($tmpfile . "*")) unless($keeptmp);

                    next TRANSCRIPT;

                }

                push(@{$pairprobs{$_}->{pairs}}, $win->{$_}) for (keys %{$win});
                push(@{$shannon[$_]}, $shannon->{$_}) for (keys %{$shannon});
                push(@windows, [$start + $trim5, $end - $trim3]);

            }

            @shannon = map { mean(@{$_}) } @shannon; # Shannon entropy vector

            # Just do this for windowed analysis, otherwise just fold
            if ($windowed) {

                # Build constraint with pairs > 0.99 probability
                foreach my $pair (sort keys %pairprobs) {

                    my ($i, $j, $prob);
                    ($i, $j) = split(/-/, $pair);

                    next if (exists $seen{$i} ||
                             exists $seen{$j});

                    for (@windows) { $pairprobs{$pair}->{n}++ if (inrange($i, $_) &&
                                                                  inrange($j, $_)); }

                    $prob = sum(@{$pairprobs{$pair}->{pairs}}) / $pairprobs{$pair}->{n};

                    # If average p(i,j) is >= 0.99
                    if ($prob >= 0.99) {

                        push(@constraint, [$i, $j, $prob]);
                        $seen{$i} = 1;
                        $seen{$j} = 1;

                    }

                }

            }

            undef($nwins);
            undef(@foldwins);
            undef(@windows);

            # We can take advantage of the rmpseudoknots() function to discard incompatible pairs
            # The rmpseudoknots() function takes the sequence, an array ref of base-pairs, and
            # optionally a scoring function to be applied (in this case the average of bp probs)
            $constraint = (rmpseudoknots($sequence, \@constraint, \&Core::Mathematics::mean))[0];

        }

        ######### End of partition function block ##########

        ######### MFE folding block ##########

        $nwins = $windowed ? max(1, floor(($length - $foldwin) / $foldstep) + 1) : 1;

        # Define windows to be analyzed
        # Windows are defined as: [start, end]
        if ($windowed &&
            $nwins > 1) {

            for (100, 50, -50, -100) {

                my $end = $foldwin - $_ - 1;
                $end = $length - 1 if ($end > $length - 1);

                next if ($end < MINWINLENGTH - 1);

                push(@foldwins, [0, $end]);

                last if ($end == $length - 1);

            }

            for (0 .. $nwins - 1) {

                my ($start, $end);
                $start = $foldstep * $_;
                $end = $_ == $nwins - 1 ? $length - 1 : $start + $foldwin - 1;
                push(@foldwins, [$start, $end]);

            }

            for (100, 50, -50, -100) {

                my $start = $length - $foldwin + $_;
                $start = 0 if (!ispositive($start));

                next if ($start > $length - MINWINLENGTH);

                push(@foldwins, [$start, $length - 1]);

                last if (!$start);

            }

        }
        else { push(@foldwins, [0, $length - 1]); }

        # Calculate MFE folding in window
        foreach my $win (@foldwins) {

            my ($start, $end, $subseq, $winconst,
                $tmpfile, @winreact);
            ($start, $end) = @{$win};

            $subseq = substr($sequence, $start, $end - $start + 1);
            @winreact = @reactivity[$start .. $end];
            $winconst = rmlonelypairs(fixdotbracket(substr($constraint, $start, $end - $start + 1)));
            $tmpfile = $id . "_" . $start . "-" . $end . "_" . threads->tid();

            my $win = winfold( file       => $tmpfile,
                               sequence   => $subseq,
                               reactivity => \@winreact,
                               pos        => $start,
                               constraint => $winconst );

            if (!$win) {

                lock(%results);
                $results{folderr}++;

                unlink(glob($tmpfile . "*")) unless($keeptmp);

                next TRANSCRIPT;

            }

            $npairs{$_}->{pairs}++ for (keys %{$win});
            push(@windows, [$start, $end]);

        }

        # Build structure with pairs in > 0.50 of windows
        foreach my $pair (sort {(split(/-/, $a))[0] <=> (split(/-/, $b))[0]} keys %npairs) {

            my ($i, $j, $n1, $n2);
            ($i, $j) = split(/-/, $pair);

            for (@windows) { $n1++ if (inrange($i, $_));
                             $n2++ if (inrange($j, $_)); }

            # If pair(i,j) is present in > 0.50 windows
            if ($npairs{$pair}->{pairs} / $n1 > 0.5 &&
                $npairs{$pair}->{pairs} / $n2 > 0.5) { push(@keptpairs, [$i, $j]); }

        }

        $entry = Data::Sequence::Structure->new( id          => $id,
                                                 sequence    => $sequence,
                                                 basepairs   => \@keptpairs,
                                                 lonelypairs => $nlp ? 0 : 1 );

        # Build dotplot of pairing probabilities (only if necessary)
        if ($windowed ||
            $dp ||
            $sh) {

            foreach my $pair (keys %pairprobs) {

                my ($i, $j) = split(/-/, $pair);
                push(@dotplot, [$i, $j, mean(@{$pairprobs{$pair}->{pairs}})]);

            }

            @dotplot = sort {$a->[0] <=> $b->[0]} @dotplot;

        }

        undef(@foldwins);

        ######### End of MFE folding block ##########

        ######### Pseudoknots detection block ##########

        if ($pk) { # Pseudoknot detection

            my (@keptpkpairs, %pkpairs, %basepairs, %pkbases);
            $nwins = $windowed ? max(1, floor(($length - $pkwin) / $pkstep) + 1) : 1;

            # Define windows to be analyzed
            # Windows are defined as: [start, end]
            if ($windowed &&
                $nwins > 1) {

                for (50, 100) {

                    my $end = $pkwin - $_ - 1;

                    last if ($end < MINWINLENGTH - 1);

                    push(@foldwins, [0, $end]);

                }

                for (0 .. $nwins - 1) {

                    my ($start, $end);
                    $start = $pkstep * $_;
                    $end = $_ == $nwins - 1 ? $length - 1 : $start + $pkwin - 1;
                    push(@foldwins, [$start, $end]);

                }

                for (50, 100) {

                    my $start = $length - $pkwin + $_;

                    last if ($start > $length - MINWINLENGTH);

                    push(@foldwins, [$start, $length - 1]);

                }

            }
            else { push(@foldwins, [0, $length - 1]); }

            # Predict pseudoknot in window
            foreach my $win (@foldwins) {

                my ($start, $end, $subseq, $tmpfile,
                    $winconst, @winreact);
                ($start, $end) = @{$win};

                $subseq = substr($sequence, $start, $end - $start + 1);
                $winconst = fixdotbracket(substr($entry->structure(), $start, $end - $start + 1));
                @winreact = @reactivity[$start .. $end];
                $tmpfile = $id . "_" . $start . "-" . $end . "_" . threads->tid();

                my ($winpk, $winbp) = pkdetect( file       => $tmpfile,
                                                sequence   => $subseq,
                                                reactivity => \@winreact,
                                                pos        => $start,
                                                constraint => $winconst );

                if (!$winpk) {

                    lock(%results);
                    $results{pkerr}++;

                    unlink(glob($tmpfile . "*")) unless($keeptmp);

                    next TRANSCRIPT;

                }

                $pkpairs{$_}++ for (keys %{$winpk});
                $basepairs{$_}++ for (keys %{$winbp});
                push(@windows, [$start, $end]);

            }

            # Discard pseudoknotted pairs in < 0.50 of windows
            foreach my $pair (keys %pkpairs) {

                my ($i, $j, $n1, $n2);
                ($i, $j) = split(/-/, $pair);

                for (@windows) { $n1++ if (inrange($i, $_));
                                 $n2++ if (inrange($j, $_)); }

                # We essentially check whether the pseudoknot base-pair exists in other windows,
                # even if it has not been marked as a pseudoknot
                $pkpairs{$pair} += $basepairs{$pair} if (exists $basepairs{$pair});

                # If pseudoknotted pair is present in > 0.50 windows
                push(@pkpairs, [$i, $j]) if ($pkpairs{$pair} / $n1 > 0.5 &&
                                             $pkpairs{$pair} / $n2 > 0.5);

            }

            # In the pkdetect() function, we have already discarded the pk helices that overlap by more than 50%
            # with helices in the MFE structure. Now, we remove the pairs from the MFE structure that still overlap (if any)
            %pkbases = map { $_ => 1 } map { @$_ } @pkpairs;
            @keptpairs = grep { !exists $pkbases{$_->[0]} && !exists $pkbases{$_->[1]} } @keptpairs;

            # Shouldn't be necessary anymore
            # In case we have incompatible base-pairs, we let rmpseudoknots() resolve that
            #@keptpkpairs = rmpseudoknots($sequence, [ @keptpairs, @pkpairs ]);
            #@pkpairs = @{$keptpkpairs[1]} ? @{$keptpkpairs[1]} : listpairs($keptpkpairs[0]);

            undef($nwins);
            undef(@foldwins);
            undef(@windows);

        }

        ######### End of pseudoknots detection block ##########

        $entry = Data::Sequence::Structure->new( id          => $id,
                                                 sequence    => $sequence,
                                                 basepairs   => [ @keptpairs, @pkpairs ],
                                                 pseudoknots => 1,
                                                 lonelypairs => $nlp ? 0 : 1 );
        $energy = RNA::energy_of_struct($sequence, $entry->structure());
        $energy += pseudodG($entry->structure(), \@reactivity) if (!$ignore);
        $entry->energy(sprintf("%.2f", $energy));
        $file = $output . "structures/" . $id . "." . ($ct ? "ct" : "db");

        # Fix the ID changed by ViennaRNA
        $entry->id($id) if ($method == 1);

        eval { $io = Data::IO::Sequence->new( file   => $file,
                                              mode   => "w",
                                              format => $ct ? "CT" : "Vienna" ); };

        if ($@) {

            lock(%results);
            $results{folderr}++;

            next;

        }

        $io->write($entry);
        $io->close();

        if ($dp) {

            open(my $wh, ">" . $output . "dotplot/" . $id . ".dp") or next;
            select((select($wh), $|=1)[0]);
            print $wh length($sequence) . "\ni\tj\t-log10(Probability)\n";
            print $wh join("\t", $_->[0] + 1, $_->[1] + 1, -logarithm($_->[2], 10)) . "\n" for (@dotplot);
            close($wh);

        }

        if ($sh) {

            my $i = 0;

            open(my $wh, ">" . $output . "shannon/" . $id . ".wig") or next;
            select((select($wh), $|=1)[0]);

            print $wh "track type=wiggle_0 name=\"" . $id . " Shannon entropy\"\n" .
                      "variableStep chrom=" . $id . "\n";

            for (@shannon) {

                $i++;
                print $wh $i . " " . $_ . "\n";

            }

            close($wh);

        }

        { lock(%results);
          $results{folded}++;

          print CLRRET . "[+] Folding RNA structures [Last: " . $id . "]"; }

        # Generate graphical summary of structure
        if ($img) {

            my ($file, $image, $io, $reactivity,
                $shannon, $mea, $pairprob, $ruler,
                $ticksby, $minheight, $maxheight, $sum,
                $medianShape, $medianShannon, $winSize);

            # Plot only base-pairing probabilities >= 5%
            @dotplot = grep { $_->[2] >= 0.05 } sort { $a->[2] <=> $b->[2] } @dotplot;
            $sum = sum(grep { isnumeric($_) } @reactivity);
            $minheight = 250;
            $maxheight = 500;
            $winSize = 25;

            if ($windowed ||
                $dp ||
                $sh) {

                $minheight *= 2;
                $maxheight *= 2;

            }

            $ticksby = max(1, round($length / 10));
            $file = $output . "images/" . $id . ".svg";
            $image = Graphics::Container->new( height  => abs(maprange(0, 1000, -$maxheight, -$minheight, min($length, 1000))), # Min: 500 / Max: 1000px
                                               width   => 1000,
                                               spacing => 0.02 );
            $io = Data::IO->new( file    => $file,
                                 mode    => "w",
                                 binmode => ":encoding(utf-8)" );

            if ($sum) {

                $reactivity = Graphics::Object::Barplot->new( fontsize  => abs(maprange(0, 1000, -30, -10, min($length, 1000))), # Min: 10pt / Max: 30pt
                                                              height    => 1,
                                                              values    => [ map { isnumeric($_) ? min($_, 2) : "NaN" } @reactivity ],
                                                              stdev     => [$xmlref->reactivity_error()],
                                                              plotstdev => "up",
                                                              yname     => "Reactivity",
                                                              barfill   => [ map { $_ < 0.3 ? "black" : ($_ < 0.7 ? "rgb(255,204,0)" : "rgb(153,25,23)") } @reactivity ],
                                                              barstroke => [ map { $_ < 0.3 ? "black" : ($_ < 0.7 ? "rgb(255,204,0)" : "rgb(153,25,23)") } @reactivity ] );

                if ($plotMedianShape) {

                    if (2 * $winSize + 1 < $length) {

                        my ($medianReact, @winReact);
                        @winReact = ("NaN") x $length;
                        $medianReact = median(grep { isnumeric($_) } @reactivity);

                        for(my $i = $winSize; $i < @reactivity - $winSize; $i += 1) {

                            my (@win, @i);
                            @win = @reactivity[$i - $winSize .. $i + $winSize];
                            @i = grep { isnumeric($win[$_]) } 0 .. $#win;

                            if (@i / @win >= 0.25) {

                                @win = @win[@i];
                                $winReact[$i] = median(@win) - $medianReact;

                            }

                        }

                        $medianShape = Graphics::Object::Path->new( fontsize => abs(maprange(0, 1000, -30, -10, min($length, 1000))), # Min: 10pt / Max: 30pt
                                                                    height   => 1,
                                                                    values   => \@winReact,
                                                                    yname    => "Median reactivity",
                                                                    fill     => "black" );

                    }

                }

            }

            $mea = Graphics::Object::RNAarcs->new( height    => 2,
                                                   length    => $length,
                                                   flip      => "down",
                                                   basepairs => \@keptpairs,
                                                   pkpairs   => \@pkpairs );

            $ruler = Graphics::Object::Ruler->new( fontsize => abs(maprange(0, 1000, -30, -10, min($length, 1000))),
                                                   height   => 1,
                                                   range    => [0, $length],
                                                   ticksby  => $ticksby,
                                                   name     => "Position (nt)",
                                                   toend    => 1 );

            # Just plot shannon and pairing probs if we have generated this data
            if ($windowed ||
                $dp ||
                $sh) {

                $shannon = Graphics::Object::Path->new( fontsize => abs(maprange(0, 1000, -30, -10, min($length, 1000))),
                                                        height   => 1,
                                                        values   => \@shannon,
                                                        fill     => "rgb(145, 106, 40)",
                                                        stroke   => "",
                                                        yname    => "Shannon" );
                $pairprob = Graphics::Object::RNAarcs->new( height    => 2,
                                                            length    => $length,
                                                            flip      => "down",
                                                            basepairs => [ map { [$_->[0], $_->[1]] } @dotplot ],
                                                            stroke    => [ map { $_->[2] < 0.1 ? "rgb(150,150,150)" : ($_->[2] < 0.4 ? "rgb(255,204,0)" : ($_->[2] < 0.7 ? "rgb(71,142,204)" : "rgb(81,183,71)")) } @dotplot ] );

                if ($plotMedianShannon && 2 * $winSize + 1 < $length) {

                    my ($medianShan, @winShannon);
                    @winShannon = ("NaN") x $length;
                    $medianShan = median(grep { isnumeric($_) } @shannon);

                    for(my $i = $winSize; $i < @shannon - $winSize; $i += 1) {

                        my (@win, @i);
                        @win = @shannon[$i - $winSize .. $i + $winSize];
                        @i = grep { isnumeric($win[$_]) } 0 .. $#win;

                        if (@i / @win >= 0.25) {

                            @win = @win[@i];
                            $winShannon[$i] = median(@win) - $medianShan;

                        }

                    }

                    $medianShannon = Graphics::Object::Path->new( fontsize => abs(maprange(0, 1000, -30, -10, min($length, 1000))), # Min: 10pt / Max: 30pt
                                                                  height   => 1,
                                                                  values   => \@winShannon,
                                                                  yname    => "Shannon",
                                                                  fill     => "rgb(145, 106, 40)" );

                }

                if ($sum) { $image->addobjects($reactivity, ($plotMedianShape && $medianShape ? $medianShape : 0), $mea, $shannon, ($plotMedianShannon && $medianShannon ? $medianShannon : 0), $pairprob, 0.05, $ruler); }
                else { $image->addobjects($mea, $shannon, ($plotMedianShannon && $medianShannon ? $medianShannon : 0), $pairprob, 0.05, $ruler); }

            }
            else {

                if ($sum) { $image->addobjects($reactivity, ($plotMedianShape && $medianShape ? $medianShape : 0), $mea, 0.05, $ruler); }
                else { $image->addobjects($mea, 0.05, $ruler); }

            }

            $io->write($image->xml());

        }

    }

}

##
#  Pseudoknots detection
#
#  pkdetect( file       => <temporary file prefix>,
#            sequence   => <window sequence>,
#            reactivity => <ARRAY ref of win reactivities>,
#            pos        => <true position> );
##

sub pkdetect {

    my %parameters = @_;

    my ($ret, $fastafile, $cmd, $energy,
        $pktollerance, $mfetollerance, $io, $count,
        @subopt, @results, @hardconstraint, @pkpairs,
        @basepairs, @pkreact, %pkpairs, %mfepaired,
        %candidatepk, %basepairs);
    $count = 0;
    $fastafile = $parameters{file} . ".fa";
    @hardconstraint = @{hardbases(@{$parameters{reactivity}})} if (!$ignore && $hc);

    # Writes temporary constraint file and sequence
    return unless(seq2fasta($parameters{file}, $parameters{file}, $parameters{sequence}));
    if (!$ignore) { return unless(xml2shape($parameters{file}, $parameters{reactivity})); }
    return unless(applyhardconstraint($parameters{file}, \@hardconstraint, $parameters{constraint}, $pkmethod == 2 ? 2 : $method));

    foreach my $helix (@{(listhelices($parameters{constraint}, 1))[0]}) { %mfepaired = (%mfepaired, map { $_ => 1 } (@{$helix->{h5bases}}, @{$helix->{h3bases}})); }

    if ($pkmethod == 1) {

        $cmd = $rnasubopt . " -p " . $pksubopt;
        $cmd .= " -C" if (!$ignore);

        $energy = RNA::energy_of_struct($parameters{sequence}, $parameters{constraint});
        $energy += pseudodG($parameters{constraint}, $parameters{reactivity}) if (!$ignore);
        #$mfetollerance = $energy - ($energy * ($entry->length() > 100 ? 0.25 : 0.2));
        #$mfetollerance = $energy - ($energy * 0.25); # We use increased tollerance due to some differences between RNAfold and ShapeKnots energy calculation
        $mfetollerance = $energy - ($energy * (length($parameters{constraint}) > 100 ? max($pkpercentmfe, 0.25) : $pkpercentmfe));
        $pktollerance = $energy - ($energy * 0.1);

        foreach my $line (split(/\n/, `cat '$fastafile' | $cmd $noshapevrfoldparams`)) {

            next if (!isdotbracket($line));

            my $suboptenergy = RNA::energy_of_struct($parameters{sequence}, $line);
            $suboptenergy += pseudodG($line, $parameters{reactivity}) if (!$ignore);

            # Here we compare the suboptimal energy and the mfetollerance down to the 1st decimal digit only
            # to avoid being too stringent (in some cases the optimal helix is within less than 0.1kcal/mol from the tollerance)
            push(@subopt, [$line, $suboptenergy]) if (sprintf("%.1f", $suboptenergy) <= sprintf("%.1f", $mfetollerance));

        }

        if (!$nozuker) {

            my $structs = 0;

            # I added this to sample suboptimal structures according to Zuker (increases the folding space searched)
            foreach my $line (split(/\n/, `cat '$fastafile' | $rnasubopt -z`)) {

                last if ($structs == $zukersubopt);

                my @line = split(" ", $line);

                next if (!isdotbracket($line[0]));

                my $suboptenergy = RNA::energy_of_struct($parameters{sequence}, $line[0]);
                $suboptenergy += pseudodG($line[0], $parameters{reactivity}) if (!$ignore);

                # Here we compare the suboptimal energy and the mfetollerance down to the 1st decimal digit only
                # to avoid being too stringent (in some cases the optimal helix is within less than 0.1kcal/mol from the tollerance)
                push(@subopt, [$line[0], $suboptenergy]) if (sprintf("%.1f", $suboptenergy) <= sprintf("%.1f", $mfetollerance));

                $structs++;

            }

        }

        @subopt = uniq(@subopt);

        foreach my $subopt (@subopt) {

            foreach my $helix (@{(listhelices($subopt->[0], $nlp ? 0 : 1))[0]}) {

                my ($pairedinmfe, $h5, $h3, $tmpsubopt,
                    $tmpenergy, @tmpsubopt, @pkbases);
                @tmpsubopt = split(//, $subopt->[0]);
                @pkbases = (@{$helix->{h5bases}}, @{$helix->{h3bases}});
                $pairedinmfe += $mfepaired{$_} for (@pkbases);

                next if ($pairedinmfe / @pkbases > 0.5);

                $tmpsubopt[$_] = "." for (@pkbases);
                $tmpsubopt = join("", @tmpsubopt);
                $tmpenergy = RNA::energy_of_struct($parameters{sequence}, $tmpsubopt);
                $tmpenergy += pseudodG($tmpsubopt, $parameters{reactivity}) if (!$ignore);

                $candidatepk{join("-", @pkbases)} = { bases  => [$helix->{h5bases}, $helix->{h3bases}],
                                                      energy => $subopt->[1] - $tmpenergy };

                # Patched (instead of calculating the energy gain by ourselves, now we just let ViennaRNA do the dirty job):
                #$h5 = substr($parameters{sequence}, $helix->{h5bases}->[-1], $helix->{h5bases}->[0] - $helix->{h5bases}->[-1] + 1);
                #$h3 = substr($parameters{sequence}, $helix->{h3bases}->[0], $helix->{h3bases}->[-1] - $helix->{h3bases}->[0] + 1);

                #$candidatepk{join("-", @pkbases)} = { bases  => [$helix->{h5bases}, $helix->{h3bases}],
                #								      energy => RNA::duplexfold($h5, $h3)->{energy} };

            }

        }

        undef(@subopt);

        foreach my $pk (sort {$candidatepk{$a}->{energy} <=> $candidatepk{$b}->{energy}} keys %candidatepk) {

            last if ($count == $pkmax);

            my ($constraint, $constfile, @pkbases, %seen);
            @pkbases = grep { !exists $mfepaired{$_} } (@{$candidatepk{$pk}->{bases}->[0]}, @{$candidatepk{$pk}->{bases}->[1]});
            $constfile = $parameters{file} . "_pkconstraint_" . $count;

            return unless(seq2fasta($constfile, $constfile, $parameters{sequence}));
            return unless(applyhardconstraint($constfile, [@hardconstraint, @pkbases], $parameters{constraint}, 1));

            $cmd = $rnasubopt . " -p 100";
            $cmd .= " -C" if (!$ignore);
            $cmd .= " --shape='" . $parameters{file} . ".shape'" if (!$ignore);

            foreach my $line (split(/\n/, `cat '$constfile.fa' | $cmd $vrfoldparams`)) {

                next if (!isdotbracket($line));
                next if (exists $seen{$line});

                $seen{$line} = 1;
                my $suboptenergy = RNA::energy_of_struct($parameters{sequence}, $line);
                $suboptenergy += pseudodG($line, $parameters{reactivity}) if (!$ignore);

                if ($suboptenergy < $mfetollerance) {

                    my @pairs = listpairs($line);

                    for (0 .. $#{$candidatepk{$pk}->{bases}->[0]}) {

                        my ($i, $j) = ($candidatepk{$pk}->{bases}->[0]->[$_], $candidatepk{$pk}->{bases}->[1]->[$_]);
                        push(@pairs, [$i, $j]);

                    }

                    push(@subopt, { pairs   => \@pairs,
                                    energy  => $suboptenergy + $candidatepk{$pk}->{energy} });

                }

            }

            $count++;

        }

        foreach my $struct (sort {$a->{energy} <=> $b->{energy}} @subopt) {

            my ($dotbracket, $pkpairs, $pkregion, $noilregion,
                $ss, $ne, $il, $pkenergy, $ildb, @il);
            ($dotbracket, $pkpairs) = rmpseudoknots($parameters{sequence}, [ @{$struct->{pairs}} ]);
            ($ss, $ne, $il) = (0, 0, 0);

            next if (@{$pkpairs} <= 1);

            $pkregion = substr($dotbracket, $pkpairs->[0]->[0], $pkpairs->[0]->[1] - $pkpairs->[0]->[0] + 1);
            ($ss) = $pkregion =~ tr/././;
            $noilregion = fixdotbracket($pkregion);
            $ne = scalar(@{(listhelices($noilregion))[0]});
            $ildb = join("", map { substr($pkregion, $_, 1) eq substr($noilregion, $_, 1) ? "." : substr($pkregion, $_, 1) } 0 .. length($pkregion) - 1);

            while ($ildb =~ m/((?:\(+.?\(*)|(?:\)+.?\)*))/g) {

                my ($helix, $length);
                $helix = $1;
                ($length) = $helix =~ tr/()/()/;
                push(@il, $length);

            }

            $il += $_ * ($lambda{($_ < 2 ? 2 : ($_ > 15 ? 15 : $_))} ** 2) for (@il);
            $il ||= 1;

            $pkenergy = $struct->{energy} + ($p1 * ($ss == 0 && $ne == 0 ? 1 : logarithm((6.5 ** 2) * $ss + (15 ** 2) * $ne, Core::Mathematics::e)) + $p2 * logarithm($il, Core::Mathematics::e));

            push(@results, { pkpairs => $pkpairs,
                             energy  => $pkenergy }) if ($pkenergy < $pktollerance);

        }

        if (@results) {

            my $result = (sort {$a->{energy} <=> $b->{energy}} @results)[0];
            @pkpairs = @{$result->{pkpairs}};

        }


    }
    else {

        $cmd = "'" . $fastafile . "' '" . $parameters{file} . ".ct' -p1 " . $p1 . " -p2 " . $p2 . " -ip " . ($pkpercentmfe * 100) . " -ph " . $pkmax;
        $cmd .= " -sh '" . $parameters{file} . ".shape'" if (!$ignore);
        #$cmd .= " -C '" . $parameters{file} . ".constraint'" if ($hc); # ShapeKnots takes -C parameter, but it is ignored
        $ret = `$shapeknots $cmd $skparams 2>&1`;

        return if ($ret !~ m/#+\s+DONE\s+#+/m);

        # If the sequence is all single-stranded, ShapeKnots may return an empty CT file
        if (-s $parameters{file} . ".ct") {

            eval { $io = Data::IO::Sequence->new( file        => $parameters{file} . ".ct",
                                                  pseudoknots => 1,
                                                  lonelypairs => $nlp ? 0 : 1 ); };

            if ($@) { return; }

            if (my $entry = $io->read()) {

                @pkpairs = $entry->pkpairs();
                @basepairs = $entry->basepairs();

            }
            else { return; }

        }

    }

    if (my @mapPkPairs = map {@$_} @pkpairs) {

        my $pairedinmfe += $mfepaired{$_} for (@mapPkPairs);

        return if ($pairedinmfe / scalar(@mapPkPairs) > 0.5);

    }

    @pkreact = grep { !isnan($_) } @{$parameters{reactivity}}[sort {$a <=> $b} map {@$_} @pkpairs];

    if ($ignore ||
        !@pkreact ||
        mean(@pkreact) <= $pkcutoff) {

        $pkpairs{($_->[0] + $parameters{pos}) . "-" . ($_->[1] + $parameters{pos})} = 1 for (@pkpairs);
        $basepairs{($_->[0] + $parameters{pos}) . "-" . ($_->[1] + $parameters{pos})} = 1 for (@basepairs);

    }

    unlink(glob($parameters{file} . "*")) unless($keeptmp);

    return(\%pkpairs, \%basepairs);

}

##
#  Windowed folding function
#
#  winfold( file       => <temporary file prefix>,
#           sequence   => <window sequence>,
#           reactivity => <ARRAY ref of window reactivities>,
#           pos        => <true position>,
#           constraint => <base-pair constraint from windowed partition>,
#           pseudoknot => <ARRAY of indexes of pseudoknotted bases> );
##

sub winfold {

    my %parameters = @_;

    my ($ret, $cmd, $io, @hardconstraint,
        %pairs);
    @hardconstraint = @{hardbases(@{$parameters{reactivity}})} if (!$ignore && $hc);

    # Writes temporary constraint file and sequence
    return unless(seq2fasta($parameters{file}, $parameters{file}, $parameters{sequence}));
    if (!$ignore) { return unless(xml2shape($parameters{file}, $parameters{reactivity})); }
    return unless(applyhardconstraint($parameters{file}, \@hardconstraint, $parameters{constraint}));

    if ($method == 1) { # ViennaRNA

        $cmd = $viennarna . " --infile='" . $parameters{file} . ".fa' --outfile='" . $parameters{file} . ".fold' -C --enforceConstraint";
        $cmd .= " --shape='" . $parameters{file} . ".shape'" if (!$ignore);

        $ret = `$cmd $vrfoldparams --noPS 2>/dev/null`;

        my $outFile = (-e $parameters{file} . ".fold_" . $parameters{file} . ".fold" ? $parameters{file} . ".fold_" . $parameters{file} . ".fold" : $parameters{file} . ".fold");

        if (!-s $outFile) {

            $cmd = $viennarna . " --infile='" . $parameters{file} . ".fa' --outfile='" . $parameters{file} . ".fold' -C";
            $cmd .= " --shape='" . $parameters{file} . ".shape'" if (!$ignore);

            $ret = `$cmd $vrfoldparams --noPS 2>/dev/null`;

        }

    }
    else { # RNAstructure

        $cmd = $rnastructure . " '" . $parameters{file} . ".fa' '" . $parameters{file} . ".ct' -C '" . $parameters{file} . ".constraint'";
        $cmd .= " -sh '" . $parameters{file} . ".shape'" if (!$ignore);

        $ret = `$cmd $rsfoldparams 2>&1`;

        return if ($ret !~ m/Single strand folding complete\./);

    }

    eval { $io = Data::IO::Sequence->new( file        =>  $method == 1 ? (-e $parameters{file} . ".fold_" . $parameters{file} . ".fold" ? $parameters{file} . ".fold_" . $parameters{file} . ".fold" : $parameters{file} . ".fold") : $parameters{file} . ".ct",
                                          lonelypairs => $nlp ? 0 : 1 ); };

    if ($@) { return; }

    if (my $entry = $io->read()) {

        foreach my $pair ($entry->basepairs()) { # i,j numbering is 0-based

            $_ += $parameters{pos} for (@{$pair});
            $pairs{$pair->[0] . "-" . $pair->[1]} = 1;

        }

    }
    else { return; }

    unlink(glob($parameters{file} . "*")) unless($keeptmp);

    return(\%pairs);

}

##
#  Windowed partition function calculation
#
#  partition( file       => <temporary file prefix>,
#             sequence   => <window sequence>,
#             reactivity => <ARRAY ref of window reactivities>,
#             pos        => <true position>,
#             trim5      => <n bases to trim from win 5'>,
#             trim3      => <n bases to trim from win 3'> );
##

sub partition {

    my %parameters = @_;

    my ($ret, $cmd, @hardconstraint, %pairs,
        %shannon);
    @hardconstraint = @{hardbases(@{$parameters{reactivity}})} if (!$ignore && $hc);

    # Fill window's Shannon entropy with 0
    %shannon = map { $_ => 0 } ($parameters{pos} + $parameters{trim5} .. $parameters{pos} + length($parameters{sequence}) - $parameters{trim3} - 1);

    # Writes temporary constraint file and sequence
    return unless(seq2fasta($parameters{file}, $parameters{file}, $parameters{sequence}));
    if (!$ignore) { return unless(xml2shape($parameters{file}, $parameters{reactivity})); }
    return unless(applyhardconstraint($parameters{file}, \@hardconstraint, $parameters{constraint}));

    if ($method == 1) { # ViennaRNA

        $cmd = $viennarna . " -p --infile='" . $parameters{file} . ".fa'";
        $cmd .= " --shape='" . $parameters{file} . ".shape' -C --enforceConstraint" if (!$ignore);

        $ret = `$cmd $vrfoldparams --noPS 2>/dev/null`;

        open(my $fh, "<", $parameters{file} . "_dp.ps") or return;
        while(<$fh>) {

            if ($_ =~ m/^(\d+) (\d+) ([\d\.]+(?:e-\d+)?) ubox$/) {

                my ($i, $j, $p) = ($1, $2, $3);

                next if ($i <= $parameters{trim5} ||
                         $j >= length($parameters{sequence}) - $parameters{trim3});

                $i += $parameters{pos} - 1;         # Base numbering is 1-based
                $j += $parameters{pos} - 1;
                $p = $p ** 2;                       # ViennaRNA returns sqrt(p(i,j))

                $pairs{$i . "-" . $j} = $p;
                $shannon{$i} += $p * logarithm($p, 10);
                $shannon{$j} += $p * logarithm($p, 10);

            }

        }
        close($fh);

    }
    else { # RNAstructure

        $cmd = $partition . " '" . $parameters{file} . ".fa' '" . $parameters{file} . ".pfs'";
        $cmd .= " -sh '" . $parameters{file} . ".shape' -C '" . $parameters{file} . ".constraint'" if (!$ignore);

        $ret = `$cmd $rsfoldparams 2>&1`;

        return if ($ret !~ m/Single strand partition function complete\./);

        $cmd = $probplot . " -t '" . $parameters{file} . ".pfs' '" . $parameters{file} . ".pfs.txt'";
        $ret = `$cmd 2>&1`;

        return if ($ret !~ m/Probability dot plot complete\./);

        open(my $fh, "<", $parameters{file} . ".pfs.txt") or return;
        while(<$fh>) {

            if ($_ =~ m/^(\d+)\t(\d+)\t([\d\.]+(?:e-\d+)?)$/) {

                my ($i, $j, $p) = ($1, $2, $3);

                next if ($i <= $parameters{trim5} ||
                         $j >= length($parameters{sequence}) - $parameters{trim3});

                $i += $parameters{pos} - 1;         # Base numbering is 1-based
                $j += $parameters{pos} - 1;
                $p = 10 ** (-$p);                   # ProbabilityPLot returns -log10(p(i,j))

                $pairs{$i . "-" . $j} = $p;
                $shannon{$i} += $p * logarithm($p, 10);
                $shannon{$j} += $p * logarithm($p, 10);

            }

        }
        close($fh);

    }

    $_ = -$_ for (values %shannon);

    unlink(glob($parameters{file} . "*")) unless($keeptmp);

    return(\%pairs, \%shannon);

}

sub xml2shape {

    my ($file, $reactivity) = @_;

    my $i = 0;

    open(my $wh, ">", $file . ".shape") or return();
    select((select($wh), $|=1)[0]);
    for (@{$reactivity}) {

        $i++;

        #next if (isnan($_));

        print $wh $i . " " . (isnan($_) ? -999 : $_) . "\n";

    }
    close($wh);

    return(1);

}

sub applyhardconstraint {

    my ($file, $hardbases, $constraint, $mode) = @_;

    $mode ||= $method;
    $hardbases = [ sort {$a <=> $b} @{$hardbases} ];

    if ($mode == 1) { # ViennaRNA

        my @constraint = split(//, $constraint);
        $constraint[$_] = "x" for (@{$hardbases});

        # Appends constraint to FASTA file
        open(my $wh, ">>", $file . ".fa") or return;
        print $wh join("", @constraint);
        close($wh);

        return(1);

    }
    else { # RNAstructure

        open(my $wh, ">", $file . ".constraint") or return();
        select((select($wh), $|=1)[0]);

        print $wh "DS:\n-1\nSS:\n";

        print $wh ++$_ . "\n" for (@{$hardbases});

        print $wh "-1\nMod:\n-1\nPairs:\n";

        if ($constraint) { print $wh ++$_->[0] . " " . ++$_->[1] . "\n" for (listpairs($constraint)); } # RNAstructure numbering is 1-based

        print $wh "-1 -1\nFMS:\n-1\nForbids:\n-1 -1";

        close($wh);

        return(1);

    }

}

sub hardbases { # Returns 0-based coords of bases to be hard-constrained

    my (@positions);

    if ($hc &&
        !$ignore) {

        foreach my $i (0 .. $#_) { push(@positions, $i) if (isnumeric($_[$i]) &&
                                                            $_[$i] >= $cutoff); }

    }

    return(\@positions);

}

sub seq2fasta {

    my ($file, $id, $sequence) = @_;

    eval {

        my ($io, $fasta);
        $io = Data::IO::Sequence->new( file      => $file . ".fa",
                                       mode      => "w",
                                       overwrite => 1,
                                       flush     => 1,
                                       format    => "fasta" );
        $fasta = Data::Sequence->new( id       => $id,
                                      sequence => $sequence );

        $io->write($fasta);

    };

    if ($@) { return(); }

    return(1);

}

##
# Pseudo dG calculation
#
# Calculates pseudo free energy contribution given structure and reactivity
# Essentially, the pseudodG calculated for each base, is counted twice if the base
# resides within a stack of bases, once if the base is at the terminal position of
# an helix, and is ignored if it's a lonely pair.
# When a bulge is encountered, the 2 bases immediately surrounding the bulge are
# counted once, as well as for the 2 bases to which they are paired.
##

sub pseudodG {

    my ($structure, $reactivity) = @_;

    my $dG = 0;

    foreach my $helix (@{(listhelices($structure))[0]}) {

        next if (@{$helix->{h5bases}} == 1);

        my (@h5bases, @h3bases, @diff, @external, @internal, %allbases);
        @h5bases = @{$helix->{h5bases}};
        @h3bases = @{$helix->{h3bases}};
        @external = (shift(@h5bases), shift(@h3bases), pop(@h5bases), pop(@h3bases));
        %allbases = map { $_ => 1 } (@h5bases, @h3bases);

        for ([\@h5bases, \@h3bases], [\@h3bases, \@h5bases]) {

            my (@h1, @h2, @diff);
            @h1 = @{$_->[0]};
            @h2 = @{$_->[1]};

            $diff[$_] = abs($h1[$_ + 1] - $h1[$_]) for(0 .. $#h1 - 1);

            for (my $i = 0; $i < $#h1; $i++) {

                if ($diff[$i] > 1) {

                    splice(@diff, $i, 1);
                    @external = (@external, splice(@h1, $i, 2), splice(@h2, $i, 2));
                    $i--;

                }

            }

        }

        @external = uniq(@external);
        delete($allbases{$_}) for (@external);
        @internal = map { $_ } keys %allbases;

        $dG += isnegative($reactivity->[$_]) || isnan($reactivity->[$_]) ? 0 : ($slope * log($reactivity->[$_] + 1) + $intercept) for (@external);
        $dG += isnegative($reactivity->[$_]) || isnan($reactivity->[$_]) ? 0 : 2 * ($slope * log($reactivity->[$_] + 1) + $intercept) for (@internal);

    }

    return($dG);

}

sub help {

    print "\n  [!] Error: Invalid option. Please check the help\n" if ($_[0]);

    die <<HELP;

 RF Fold (v$Core::Utils::VERSION)
 RNA Framework [http://www.rnaframework.com]

 Author:  Danny Incarnato (dincarnato[at]rnaframework.com)
 Summary: Produces RNA secondary structures using structural probing data to guide folding

 Usage:   rf-fold [Options] XML_folder/                          # Whole transcriptome
          rf-fold [Options] transcript.xml                       # Single transcript

 Options                                     Description
 -o   or --output-dir            <string>    Output directory (Default: rf_fold/)
 -ow  or --overwrite                         Overwrites output directory (if the specified path already exists)
 -ct  or --connectivity-table                Writes predicted structures in CT format (Default: Dot-bracket notation)
 -m   or --folding-method        <int>       Specifies the folding method (1-2, Default: 1): [1] ViennaRNA
                                                                                             [2] RNAstructure

 -p   or --processors            <int>       Number of processors to use for the analysis (Default: 1)
 -g   or --img                               Enables the generation of graphical reports
 -t   or --temperature           <float>     Temperature in Celsius degrees (Default: 37.0)
 -sl  or --slope                 <float>     Sets slope used with structural probing data restraints (Default: 1.8 [kcal/mol])
 -in  or --intercept             <float>     Sets intercept used with structural probing data restraints (Default: -0.6 [kcal/mol])
 -md  or --maximum-distance      <int>       Sets the maximum pairing distance in nucleotides between transcript's residues (Default: 0 [No limit])
 -nlp or --no-lonelypairs                    Disallows lonely base-pairs (1 bp helices) inside predicted structure
 -i   or --ignore-reactivity                 Ignores XML reactivity data when performing folding (MFE unconstrained prediction)
 -hc  or --hard-constraint                   Besides performing soft-constraint folding, allows specifying a reactivity cutoff (specified by -f)
                                             for hard-constraining a base to be single-stranded
 -c   or --constraints           <string>    Path to a directory containing constraint files (in dot-bracket notation), that will be used to
                                             enforce specific base-pairs in the structure models
                                             Note: pseudoknots are currently not supported
 -f   or --cutoff                <float>     Reactivity cutoff for constraining a position as unpaired (>0, Default: 0.7)
 -w   or --windowed                          Enables windowed folding
 -pt  or --partition             <string>    Path to partition executable (Default: assumes partition is in PATH)
                                             Note: by default, partition-smp will be used (if available).
 -pp  or --probabilityplot       <string>    Path to ProbabilityPlot executable (Default: assumes ProbabilityPlot is in PATH)
 -fw  or --fold-window           <int>       Window size (in nt) for performing MFE folding (>=50, Default: 600)
 -fo  or --fold-offset           <int>       Offset (in nt) for MFE folding window sliding (Default: 200)
 -pw  or --partition-window      <int>       Window size (in nt) for computing partition function (>=50, Default: 600)
 -po  or --partition-offset      <int>       Offset (in nt) for partition function window sliding (Default: 200)
 -wt  or --window-trim           <int>       Number of bases to trim from both ends of the partition windows to avoid end biases (Default: 100)
 -dp  or --dotplot                           Enables generation of dot-plots of base-pairing probabilities
 -sh  or --shannon-entropy                   Enables generation of a WIGGLE track file with per-base Shannon entropies
 -pmr or --plot-median-react                 Plots the difference between the transcript's median reactivity and the median reactivity in sliding windows
 -pms or --plot-median-shannon               Plots the difference between the transcript's median Shannon entropy and the median Shannon entropy 
                                             in sliding windows
 -pk  or --pseudoknots                       Enables detection of pseudoknots (computationally intensive)
 -ksl or --pseudoknot-slope      <float>     Sets slope used for pseudoknots prediction (Default: same as -sl <slope>)
 -kin or --pseudoknot-intercept  <float>     Sets intercept used for pseudoknots prediction (Default: same as -in <intercept>)
 -kp1 or --pseudoknot-penality1  <float>     Pseudoknot penality P1 (Default: 0.35)
 -kp2 or --pseudoknot-penality2  <float>     Pseudoknot penality P2 (Default: 0.65)
 -kt  or --pseudoknot-tollerance <float>     Maximum tollerated deviation of suboptimal structures energy from MFE (>0-1, Default: 0.5 [50%])
 -kh  or --pseudoknot-helices    <int>       Number of candidate pseudoknotted helices to evaluate (>0, Default: 100)
 -kw  or --pseudoknot-window     <int>       Window size (in nt) for performing pseudoknots detection (Default: 600)
 -ko  or --pseudoknot-offset     <int>       Offset (in nt) for pseudoknots detection window sliding (Default: 200)
 -kc  or --pseudoknot-cutoff     <float>     Reactivity cutoff for retaining a pseudoknotted helix (0-1, Default: 0.5)
 -km  or --pseudoknot-method     <int>       Algorithm for pseudoknots prediction (1-2, Default: 1): [1] RNA Framework
                                                                                                     [2] ShapeKnots
                                             Note: the chosen folding method (specified by -m) affects the algorithm used by RNA Framework
                                                   (pseudoknot detection method #1) to define the initial MFE structure
 |
 +- RNA Framework pseudoknots detection algorithm options
    -vrs or --vienna-rnasubopt      <string>    Path to ViennaRNA RNAsubopt executable (Default: assumes RNAsubopt is in PATH)
    -ks  or --pseudoknot-suboptimal <int>       Number of suboptimal structures to evaluate for pseudoknots prediction (>0, Default: 1000)
    -nz  or --no-zuker                          Disables the inclusion of Zuker suboptimal structures (reduces the sampled folding space)
    -zs  or --zuker-suboptimal                  Number of Zuker suboptimal structures to include (>0, Default: 1000)

 |
 +- ShapeKnots pseudoknots detection algorithm options
    -sk or --shapeknots             <string>    Path to ShapeKnots executable (Default: assumes ShapeKnots is in PATH)
                                                Note: by default, ShapeKnots-smp will be used (if available).

 Folding method #1 options (ViennaRNA)
 -vrf or --vienna-rnafold     <string>    Path to ViennaRNA RNAfold executable (Default: assumes RNAfold is in PATH)
 -ngu or --no-closing-gu                  Disallows G:U wobbles at the end of helices
 -cm  or --constraint-method  <int>       Method for converting reactivities into pseudo-energies (1-2, Default: 1): [1] Deigan et al., 2009
                                                                                                                     [2] Zarringhalam et al., 2012
 |
 +- Zarringhalam et al., 2012 method options
    -cc or --constraint-conversion  <int>       Method for converting reactivities to pairing probabilities (1-5, Default: 1):
                                                [1] Skip normalization step (reactivities are treated as pairing probabilities)
                                                [2] Linear mapping according to Zarringhalam et al., 2012
                                                [3] Use a cutoff to divide into paired and unpaired nucleotides (specified by -f)
                                                [4] Linear model for converting reactivities into probabilities of being unpaired
                                                [5] Linear model for converting the logarithm of reactivities into probabilities
                                                    of being unpaired
    -bf or --beta-factor            <float>     Sets the magnitude of penalities for deviations from the observed pairing probabilities (Default: 0.5)
    -ms or --model-slope            <float>     Sets the slope used by the linear model (Default: 0.68 [#4] or 1.6 [#5], requires -cc [45])
    -mi or --model-intercept        <float>     Sets the intercept used by the linear model (Default: 0.2 [#4] or -2.29 [#5], requires -cc [45])

 Folding method #2 options (RNAstructure)
 -rs or --rnastructure        <string>    Path to RNAstructure Fold executable (Default: assumes Fold is in PATH)
                                          Note: by default, Fold-smp will be used (if available).
 -d  or --data-path           <string>    Path to RNAstructure data tables (Default: assumes DATAPATH environment variable is already set)

HELP

}
